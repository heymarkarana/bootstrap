#!/usr/bin/env bash

##
##  dotFiles bootstrap script (cleaned & platform unified)
##

# Determine the original user's home directory when using sudo
if [[ -n "$SUDO_USER" ]]; then
  ORIGINAL_USER_HOME=$(eval echo "~$SUDO_USER")
else
  ORIGINAL_USER_HOME="${HOME}"
fi

#######################################################
##               Project Settings                   ##
#######################################################
DF_PROJECT_NAME="dotFiles"
REPO1="git@git.thesecretlab.io:marana/dotFiles.git"
REPO1_NAME="Kuzcotopia"
REPO2="git@github.com:heymarkarana/dotFiles.git"
REPO2_NAME="GitHub"

DF_INSTALL_FOLDER_NAME=".${DF_PROJECT_NAME}"

BIN_NAME=$(basename "$0")
COMMAND=$1
BRANCH=$2

DEFAULT_REPO="${REPO1}"
SELECTED_REPO="${DEFAULT_REPO}"
TARGET="${ORIGINAL_USER_HOME}/${DF_INSTALL_FOLDER_NAME}"

# Detect OS platform and return one of: macOS, ubuntu
detect_platform() {
  if [[ "$OSTYPE" == "darwin"* ]]; then
    echo "macOS"
  elif [[ -f "/etc/lsb-release" ]] && grep -q "Ubuntu" "/etc/lsb-release"; then
    echo "ubuntu"
  else
    echo "Error: Unsupported platform. Only macOS and Ubuntu are supported." >&2
    exit 1
  fi
}

# Get current working directory as bootstrap home
set_bootstrap_home() {
  [[ -z "$DF_BOOTSTRAP_HOME" ]] && DF_BOOTSTRAP_HOME="$(pwd)"
  echo "${DF_BOOTSTRAP_HOME}"
}

DF_PLATFORM=$(detect_platform)
DF_BOOTSTRAP_HOME=$(set_bootstrap_home)

show_help() {
  echo
  echo "Usage: ${BIN_NAME} <command> [branch|tag] [options]"
  echo
  echo "Commands:"
  echo "   install                     Set up .dotFiles from scratch. Installs ZSH and Homebrew if required."
  echo "   install [branch|tag]        Specify a branch or tag to install. Defaults to 'main'."
  echo "   refresh                     Refresh the existing .dotFiles repository."
  echo "   refresh <branch|tag>        Refresh and pull a specific branch or tag."
  echo "   refresh --hard <branch|tag> Hard reset to a specific branch or tag. Deletes and reclones the repo."
  echo
  echo "Options:"
  echo "   --repo <repository>        Specify the repository to clone from."
  echo
}

parse_arguments() {
  while [[ $# -gt 0 ]]; do
    case $1 in
      --repo)
        SELECTED_REPO=$2
        shift
        ;;
    esac
    shift
  done
}

# Usage: convert_git_remote_to_ssh /path/to/repo git@yourdomain:username/repo.git

convert_git_remote_to_ssh() {
  local repo_path="$1"
  local remote_url="$2"

  if [[ ! -d "$repo_path/.git" ]]; then
    echo "[✗] Not a Git repository: $repo_path"
    return 1
  fi

  # Derive SSH URL from provided HTTP(S) URL if given
  if [[ -n "$remote_url" ]]; then
    if [[ "$remote_url" =~ ^https?:// ]]; then
      local stripped_url="${remote_url#http://}"
      stripped_url="${stripped_url#https://}"
      remote_url="git@${stripped_url//\//:}"
    fi
  else
    remote_url=$(git -C "$repo_path" remote get-url origin)
    if [[ "$remote_url" =~ ^https?:// ]]; then
      local stripped_url="${remote_url#http://}"
      stripped_url="${stripped_url#https://}"
      remote_url="git@${stripped_url//\//:}"
    else
      echo "[i] Remote is already using SSH: $remote_url"
      return 0
    fi
  fi

  echo "[→] Setting remote 'origin' to: $remote_url"
  git -C "$repo_path" remote set-url origin "$remote_url"
}

switch_to_zsh() {
  local current_shell zsh_path

  if [[ "$DF_PLATFORM" == "macOS" ]]; then
    current_shell=$(dscl . -read /Users/"$USER" UserShell | awk '{print $2}')
  else
    if command -v getent >/dev/null 2>&1; then
      current_shell=$(getent passwd "$USER" | cut -d: -f7)
    else
      current_shell=$(grep "^$USER:" /etc/passwd | cut -d: -f7)
    fi
  fi

  zsh_path=$(command -v zsh)

  if [[ "$current_shell" == "$zsh_path" ]]; then
    echo "zsh is already the default shell. Switching for current session..."
    exec "$zsh_path"
    return 0
  fi

  if [[ "$DF_PLATFORM" == "ubuntu" ]]; then
    echo "Changing default shell to zsh..."
    chsh -s "$zsh_path"
  fi

  echo "Switching to zsh for current session..."
  exec "$zsh_path"
}

install_homebrew() {
  if [[ "$DF_PLATFORM" == "macOS" ]] && ! command -v brew &>/dev/null; then
    echo "Installing Homebrew..."
    /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
    echo 'eval "$(/opt/homebrew/bin/brew shellenv)"' >> "${ORIGINAL_USER_HOME}/.zshrc"
    eval "$(/opt/homebrew/bin/brew shellenv)"
    echo "Homebrew installation complete."
  else
    echo "Homebrew already installed or not on macOS."
  fi
}

install_zsh() {
  if ! command -v zsh &>/dev/null; then
    echo "Installing ZSH..."
    if [[ "$DF_PLATFORM" == "ubuntu" ]]; then
      sudo apt update -q && sudo apt install -y zsh
    fi
  fi
  touch "${ORIGINAL_USER_HOME}/.zshrc"
  echo "ZSH ready."
}

# Optional: Install 1Password CLI for secret management
setup_1password_optional() {
  echo ""
  echo "════════════════════════════════════════════════════════════════"
  echo "         1Password CLI Setup (Optional)         "
  echo "════════════════════════════════════════════════════════════════"
  echo ""
  echo "1Password CLI can securely manage your secrets including:"
  echo "  • API keys (Cloudflare, SMTP, etc.)"
  echo "  • SSH keys by identity"
  echo "  • Git-crypt keys"
  echo ""
  echo "If you skip this, you'll be prompted for secrets manually during"
  echo "dotFiles installation."
  echo ""

  read -p "Install 1Password CLI? (y/N): " install_op

  if [[ ! "$install_op" =~ ^[yY]$ ]]; then
    echo "⊘ Skipping 1Password setup - will use manual entry for secrets"
    return 0
  fi

  # Install op CLI if needed
  if ! command -v op &>/dev/null; then
    echo ""
    echo "Installing 1Password CLI..."

    if [[ "$DF_PLATFORM" == "macOS" ]]; then
      if command -v brew &>/dev/null; then
        if brew install --cask 1password-cli; then
          echo "✅ 1Password CLI installed"
        else
          echo "⚠ Failed to install 1Password CLI"
          return 1
        fi
      else
        echo "⚠ Homebrew required for 1Password CLI installation"
        return 1
      fi
    elif [[ "$DF_PLATFORM" == "ubuntu" ]]; then
      # Download and add 1Password GPG key
      if curl -sS https://downloads.1password.com/linux/keys/1password.asc | \
        sudo gpg --dearmor --output /usr/share/keyrings/1password-archive-keyring.gpg; then

        # Add 1Password repository
        echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/1password-archive-keyring.gpg] https://downloads.1password.com/linux/debian/$(dpkg --print-architecture) stable main" | \
          sudo tee /etc/apt/sources.list.d/1password.list > /dev/null

        # Update and install
        if sudo apt update -q && sudo apt install -y 1password-cli; then
          echo "✅ 1Password CLI installed"
        else
          echo "⚠ Failed to install 1Password CLI"
          return 1
        fi
      else
        echo "⚠ Failed to add 1Password GPG key"
        return 1
      fi
    fi
  else
    echo "✓ 1Password CLI already installed"
  fi

  # Try to authenticate
  echo ""
  echo "Authenticating with 1Password..."
  echo "You'll need your 1Password account credentials."
  echo ""

  if eval $(op signin 2>/dev/null); then
    echo ""
    echo "✅ 1Password authentication successful"
    echo ""
    echo "To enable SSH agent integration:"
    if [[ "$DF_PLATFORM" == "macOS" ]]; then
      echo "  1. Open 1Password"
      echo "  2. Settings → Developer → Enable 'Use the SSH agent'"
    elif [[ "$DF_PLATFORM" == "ubuntu" ]]; then
      echo "  • Use 1Password on your local machine to manage SSH keys"
      echo "  • Or set up a service account token for headless operation"
    fi
    echo ""
    return 0
  else
    echo ""
    echo "⚠ 1Password authentication skipped"
    echo "You can set it up later with: df 1password enable"
    echo ""
    return 1
  fi
}

verify_git_access() {
  local host
  host=$(echo "$SELECTED_REPO" | sed -n 's#.*@\([^:]*\):.*#\1#p')

  if [[ -z "$host" ]]; then
    echo "Could not parse SSH host from repository: $SELECTED_REPO"
    return 1
  fi

  echo "Verifying SSH access to ${host}..."
  
  # Add host key to known_hosts if not already present (silently)
  if ! ssh-keygen -F "$host" >/dev/null 2>&1; then
    echo "Adding ${host} to known_hosts..."
    ssh-keyscan -H "$host" >> ~/.ssh/known_hosts 2>/dev/null
  fi
  
  if ssh -o BatchMode=yes -o StrictHostKeyChecking=no -T "git@${host}" 2>&1 | grep -qi "successfully authenticated"; then
    echo "✅ SSH access to ${host} verified."
  else
    echo "❌ SSH access to ${host} failed."
    echo "Make sure your SSH key is added to ${host} (e.g., GitHub or Forgejo)."
    echo "You can manually test with: ssh -T git@${host}"
    exit 1
  fi
}

ensure_bootstrap_ssh_connectivity() {
  echo "Ensuring Bootstrap repository uses SSH connectivity..."
  
  # Get current remote URL
  local current_url
  current_url=$(git remote get-url origin 2>/dev/null)
  
  if [[ -z "$current_url" ]]; then
    echo "[✗] No origin remote found in Bootstrap repository"
    return 1
  fi
  
  echo "[i] Current Bootstrap remote: $current_url"
  
  # Check if already using SSH
  if [[ "$current_url" =~ ^git@ ]]; then
    echo "[✓] Bootstrap already using SSH: $current_url"
    return 0
  fi
  
  # Convert HTTPS to SSH based on the service detected
  if [[ "$current_url" =~ ^https:// ]]; then
    local ssh_url=""
    
    # Detect service and convert accordingly
    if [[ "$current_url" =~ github\.com ]]; then
      ssh_url=$(echo "$current_url" | sed 's|https://github\.com/|git@github.com:|')
    elif [[ "$current_url" =~ git\.thesecretlab\.io ]]; then
      ssh_url=$(echo "$current_url" | sed 's|https://git\.thesecretlab\.io/|git@git.thesecretlab.io:|')
    elif [[ "$current_url" =~ gitlab\.com ]]; then
      ssh_url=$(echo "$current_url" | sed 's|https://gitlab\.com/|git@gitlab.com:|')
    else
      echo "[✗] Unknown git service in URL: $current_url"
      return 1
    fi
    
    echo "[→] Converting Bootstrap remote to SSH: $ssh_url"
    if git remote set-url origin "$ssh_url"; then
      echo "[✓] Successfully updated Bootstrap remote to SSH"
      
      # Test SSH connectivity
      if git fetch --quiet origin 2>/dev/null; then
        echo "[✓] SSH connectivity test successful"
        return 0
      else
        echo "[✗] SSH connectivity test failed - reverting"
        git remote set-url origin "$current_url"
        return 1
      fi
    else
      echo "[✗] Failed to update remote URL"
      return 1
    fi
  else
    echo "[✗] Remote URL is not HTTPS: $current_url"
    return 1
  fi
}

install_dotfiles() {
  echo "Setting up .dotFiles..."
  install_homebrew
  install_zsh
  setup_1password_optional
  verify_git_access

  # Ensure bootstrap repo uses SSH
  ensure_bootstrap_ssh_connectivity

  local branch_or_tag="${BRANCH:-main}"

  echo "Cloning from ${SELECTED_REPO}..."
  if git clone --depth 1 --branch "${branch_or_tag}" "${SELECTED_REPO}" "${TARGET}"; then
    cd "${TARGET}" || exit 1
    echo "dotFiles setup complete."
    switch_to_zsh
  else
    echo "Git clone failed. Exiting."
    exit 1
  fi
}

refresh_dotfiles() {
  echo "Refreshing .dotFiles..."
  local branch_or_tag="${1:-main}"

  if [[ "${branch_or_tag}" == "--hard" ]]; then
    branch_or_tag="${2:-main}"
    echo "Hard reset to ${branch_or_tag}..."
    rm -rf "${TARGET}"
    if git clone --depth 1 --branch "${branch_or_tag}" "${SELECTED_REPO}" "${TARGET}"; then
      cd "${TARGET}" || exit 1
    else
      echo "Clone failed. Exiting."
      exit 1
    fi
  else
    cd "${TARGET}" || exit 1
    if git rev-parse --verify "refs/tags/${branch_or_tag}" >/dev/null 2>&1; then
      echo "Checking out tag ${branch_or_tag}..."
      git fetch --tags
      git checkout "tags/${branch_or_tag}" -b "${branch_or_tag}-branch"
    else
      echo "Pulling updates from branch ${branch_or_tag}..."
      git pull origin "${branch_or_tag}" || exit 1
    fi
  fi
}

# Main logic
parse_arguments "$@"
case ${COMMAND} in
  "" | "-h" | "--help")
    show_help
    ;;
  init)
    echo "Environment file is now managed separately. No action performed."
    ;;
  install)
    if [[ -x "${ORIGINAL_USER_HOME}/.bootstrap/GitHarness.sh" ]]; then
      "${ORIGINAL_USER_HOME}/.bootstrap/GitHarness.sh"
    fi
    install_dotfiles
    ;;
  refresh)
    refresh_dotfiles "$2"
    ;;
  *)
    echo "Unknown command: ${COMMAND}" >&2
    show_help
    exit 1
    ;;
esac